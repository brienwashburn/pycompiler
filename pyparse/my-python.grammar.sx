((single_input (or 'NEWLINE simple_stmt (seq compound_stmt 'NEWLINE)))
 (file_input (seq (rep (or 'NEWLINE stmt)) 'ENDMARKER))
 (eval_input (seq testlist (rep 'NEWLINE) 'ENDMARKER))
 (decorator (seq "@" dotted_name (opt (seq "(" (opt arglist) ")")) 'NEWLINE))
 (decorators (rep+ decorator))
 (decorated (seq decorators (or classdef funcdef)))
 (funcdef (seq "def" 'NAME parameters (opt (seq "->" test)) ":" suite))
 (parameters (seq "(" (opt typedargslist) ")"))

 (typedargslist
  ($--> (or 
	      ($--> (seq
		      ($--> (seq ($--> (seq tfpdef
		                       (opt ($--> (seq "=" test) ($ 2))))
                                       (if ($ 2)
                                        `( ,(car ($ 1)) ,($ 2) ,(cadr ($ 1)))
                                        `( ,(car ($ 1)) #f ,(cadr ($ 1)))))
		                 ($--> (rep tkwonly) $$))
                                 (if ($ 2)
                                  (recombine-arglist `(,($ 1) ,@($ 2)))
                                  (recombine-arglist `(($ 1)))))
		      (opt ($--> (seq ","
				      (opt (or targ-kwonly-kwarg
		     		               tkwarg))) 
                                 (if ($ 2)
                                  ($ 2)
                                  `(() () () () () () () ())))))
                      (if ($ 2)
                      `( (,@(car ($ 1))) (,@(caddr ($ 1))) ,(list-ref ($ 2) 2) ,(list-ref ($ 2) 3) ,(list-ref ($ 2) 4) ,(list-ref ($ 2) 5) ,(list-ref ($ 2) 6) (,@(cadr ($ 1))))
                      `( (,@(car ($ 1))) (,@(caddr ($ 1))) () () () () () (,@(cadr ($ 1))))))
	      targ-kwonly-kwarg
	      tkwarg)
        `(ARGUMENTS 
          ,`(args             ,@($ 0)) 
          ,`(args-types       ,@($ 1)) 
          ,`(varargs          ,@($ 2)) 
          ,`(kwonlyargs       ,@($ 3)) 
          ,`(kwonlyarg-types  ,@($ 4)) 
          ,`(kw_defaults      ,@($ 5))  
          ,`(kwarg            ,@($ 6)) 
          ,`(defaults         ,@($ 7)))))

 (targ-kwonly-kwarg 
      ($--> (seq
             "*" 
             tfpdef
             ($--> (rep tkwonly) (recombine-arglist $$))
             (opt ($--> (seq "," "**" tfpdef) ($ 3))))  
	     (if ($ 4)
	      `( ()  ()  (,(car ($ 2)))   (,@(car ($ 3)))  (,@(caddr ($ 3)))  (,@(cadr ($ 3)))  (,(car ($ 4)))  ())
	      `( ()  ()  (,(car ($ 2)))   (,@(car ($ 3)))  (,@(caddr ($ 3)))  (,@(cadr ($ 3)))  ()        ()))))

 (tkwonly ($--> (seq "," 
                    tfpdef 
                    (opt ($--> (seq "=" test) ($ 2) )))
                    (if ($ 3)
                     `( ,(car ($ 2)) ,($ 3) ,(cadr ($ 2)))
                     `( ,(car ($ 2)) #f ,(cadr ($ 2))))))

 (tkwarg ($--> (seq "**" tfpdef) `( () () () () () () (,(car ($ 2))) ())))


 (tfpdef ($--> (seq 'NAME        
                    (opt ($--> (seq ":" test) ($ 2))))
                    (if ($ 2)
                     `(,(string->symbol ($ 1)) ,($ 2))
                     `(,(string->symbol ($ 1)) #f))))


 (varargslist
  ($--> (or 
	      ($--> (seq
		      ($--> (seq ($--> (seq vfpdef
		                       (opt ($--> (seq "=" test) ($ 2))))
                                       (if ($ 2)
                                        `( ,($ 1) ,($ 2) #f)
                                        `( ,($ 1) #f #f)))
		                 ($--> (rep kwonly) $$))
                                 (if ($ 2)
                                  (recombine-arglist `(,($ 1) ,@($ 2)))
                                  (recombine-arglist `(($ 1)))))
		      (opt ($--> (seq ","
				      (opt (or arg-kwonly-kwarg
		     		               kwarg))) 
                                 (if ($ 2)
                                  ($ 2)
                                  `(() () () () () () () ())))))
                      (if ($ 2)
                      `( (,@(car ($ 1))) () ,(list-ref ($ 2) 2) ,(list-ref ($ 2) 3) ,(list-ref ($ 2) 4) ,(list-ref ($ 2) 5) ,(list-ref ($ 2) 6) (,@(cadr ($ 1))))
                      `( (,@(car ($ 1))) (,($ 2)) () () () () () (,@(cadr ($ 1))))))
	      arg-kwonly-kwarg
	      kwarg)
        `(ARGUMENTS 
          ,`(args             ,@($ 0)) 
          ,`(args-types       ,@($ 1)) 
          ,`(varargs          ,@($ 2)) 
          ,`(kwonlyargs       ,@($ 3)) 
          ,`(kwonlyarg-types  ,@($ 4)) 
          ,`(kw_defaults      ,@($ 5))  
          ,`(kwarg            ,@($ 6)) 
          ,`(defaults         ,@($ 7)))))

 (arg-kwonly-kwarg 
      ($--> (seq
             "*" 
             vfpdef
             ($--> (rep kwonly) (recombine-arglist $$))
             (opt ($--> (seq "," "**" vfpdef) ($ 3))))  
	     (if ($ 4)
	      `( ()  ()  (,($ 2))   (,@(car ($ 3)))  (,@(caddr ($ 3)))  (,@(cadr ($ 3)))  (,($ 4))  ())
	      `( ()  ()  (,($ 2))   (,@(car ($ 3)))  (,@(caddr ($ 3)))  (,@(cadr ($ 3)))  ()        ()))))

 (kwonly ($--> (seq "," 
                    vfpdef 
                    (opt ($--> (seq "=" test) ($ 2) )))
                    (if ($ 3)
                     `( ,($ 2) ,($ 3) #f)
                     `( ,($ 2) #f #f))))

 (kwarg ($--> (seq "**" vfpdef) `( () () () () () () (,($ 2)) ())))

 (vfpdef ($--> (seq 'NAME) (string->symbol ($ 1))))

 (stmt (or simple_stmt compound_stmt))

 (simple_stmt ($*--> (rep+/sep ";" small_stmt  #t) 'NEWLINE ($ 1)))

 (small_stmt 
  (or expr_stmt
      del_stmt
      pass_stmt
      flow_stmt
      import_stmt
      global_stmt
      nonlocal_stmt
      assert_stmt))

 (expr_stmt test) 
   #;(or ($*--> testlist_star_expr 
                       augassign 
                       (or yield_expr testlist) 
                             `(AugAssign ,($ 1) ,($ 2) ,($ 3)))
                ($*--> testlist_star_expr 
                       (rep ($*--> "=" (or yield_expr testlist_star_expr) ($ 2)))
                       (if ($ 2)
                               $$
                               '((()))))
                              `(Assign 
                                ,(if (equal? (length ($ 1)) 1) 
                                  `(targets ,($ 1))
                                  `(targets ,`(Tuple ,@($ 1))))
                                ,(if (equal? (length (car ($ 2))) 1)
                                  `(value ,@(caar ($ 2)))
                                  `(value ,`(Tuple ,@(caar ($ 2)))))))
 (testlist_star_expr (rep+/sep "," (or test star_expr) #t) )

 (augassign  (or ($--> "+=" 'Add)
                 ($--> "-=" 'Sub)
                 ($--> "*=" 'Mult)
                 ($--> "/=" 'Div)
                 ($--> "%=" 'Mod)
                 ($--> "&=" 'BitAnd)
                 ($--> "|=" 'BitOr)
                 ($--> "^=" 'BitXor)
                 ($--> "<<=" 'LShift)
                 ($--> ">>=" 'RShift)
                 ($--> "**=" 'Pow)
                 ($--> "//=" 'FloorDiv)))

 (del_stmt ($*--> "del" exprlist `(Delete ,($ 2))))

 (pass_stmt ($--> "pass" '(Pass)))
 
 (flow_stmt (or break_stmt continue_stmt return_stmt raise_stmt yield_stmt))

 (break_stmt ($*--> "break" '(Break)))

 (continue_stmt ($*--> "continue" '(Continue)))

 (return_stmt ($*--> "return" 
                     (opt testlist)
                     (if ($ 2)
                       `(Return ,($ 2))
                        '(Return))))

 (yield_stmt yield_expr)

 (raise_stmt ($*--> "raise" 
                    (opt ($*--> test 
                                (opt ($*--> "from" 
                                            test 
                                            ($ 2))) 
                                (if ($ 2) 
                                 `(,($ 1) ,($ 2)) 
                                 `(,($ 1)))))
                    (if ($ 2)
                     `(Raise ,@($ 2))
                     `(Raise ))))
                     
                     

 (import_stmt (or import_name import_from))
 (import_name (seq "import" dotted_as_names))
 (import_from
  (seq
   "from"
   (or (seq (rep (or "." "...")) dotted_name) (rep+ (or "." "...")))
   "import"
   (or "*" (seq "(" import_as_names ")") import_as_names)))
 (import_as_name (seq 'NAME (opt (seq "as" 'NAME))))
 (dotted_as_name (seq dotted_name (opt (seq "as" 'NAME))))
 (import_as_names
  (seq import_as_name (rep (seq "," import_as_name)) (opt ",")))
 (dotted_as_names (seq dotted_as_name (rep (seq "," dotted_as_name))))
 (dotted_name (seq 'NAME (rep (seq "." 'NAME))))
 (global_stmt (seq "global" 'NAME (rep (seq "," 'NAME))))
 (nonlocal_stmt (seq "nonlocal" 'NAME (rep (seq "," 'NAME))))
 (assert_stmt (seq "assert" test (opt (seq "," test))))
 (compound_stmt
  (or if_stmt
      while_stmt
      for_stmt
      try_stmt
      with_stmt
      funcdef
      classdef
      decorated))
 (if_stmt
  (seq
   "if"
   test
   ":"
   suite
   (rep (seq "elif" test ":" suite))
   (opt (seq "else" ":" suite))))
 (while_stmt (seq "while" test ":" suite (opt (seq "else" ":" suite))))
 (for_stmt
  (seq "for" exprlist "in" testlist ":" suite (opt (seq "else" ":" suite))))
 (try_stmt
  (seq
   "try"
   ":"
   suite
   (or (seq
        (rep+ (seq except_clause ":" suite))
        (opt (seq "else" ":" suite))
        (opt (seq "finally" ":" suite)))
       (seq "finally" ":" suite))))
 (with_stmt (seq "with" with_item (rep (seq "," with_item)) ":" suite))

 (with_item (seq test (opt (seq "as" expr))))

 (except_clause ($*--> "except" 
                       (opt ($*--> test 
                                   (opt ($*--> "as" 'NAME (string->symbol ($ 2))))
                                   (if ($ 2) 
                                       `(,($ 1) ,($ 2)) 
                                       `(,($ 1) #f))))
                       (if ($ 2)
                        ($ 2)   
                        `(#f #f))))

 (suite (or simple_stmt  
            ($*--> 'NEWLINE 'INDENT (rep+ stmt) 'DEDENT ($ 3))))
 
 (test (or ($*--> or_test (opt ($*--> "if" or_test "else" test `(,($ 2) ,($ 4))))
								(if ($ 2)
								 `(IfExp ,(car ($ 2)) ,($ 1) ,(cadr ($ 2)))
								 ($ 1)))
            lambdef))
 (test_nocond (or or_test lambdef_nocond))
 (lambdef ($*--> "lambda" (opt varargslist) ":" test
												(if ($ 4)
												 `(Lambda ,($ 2) ,($ 4))
													`(Lambda ,($ 3)))))
 (lambdef_nocond ($*--> "lambda" (opt varargslist) ":" test_nocond
			(if ($ 4)
			 `(Lambda ,($ 2) ,($ 4))
				`(Lambda ,($ 3)))))

 (or_test (or ($--> (seq or_test "or" and_test) `(BoolOp Or ,($ 1) ,($ 3)))
                 and_test))

 (and_test (or ($--> (seq and_test "and" not_test) `(BoolOp And ,($ 1) ,($ 3)))
                 not_test))

 (not_test (or ($--> (seq "not" not_test) `(UnaryOp Not ,($ 2)))
               comparison))

 (comparison (or ($--> (seq comparison comp_op expr) `(Compare (left ,($ 1)) ,($ 2) (comparators ,($ 3))))
                 expr))

 (comp_op ($--> (or ($--> "<" 'Lt)
		    ($--> ">" 'Gt)
		    ($--> "==" 'Eq)
		    ($--> ">=" 'GtE)
		    ($--> "<=" 'LtE)
		    ($--> "!=" 'NotEq)
		    ($--> "in" 'In)
		    ($*--> "not" "in" 'NotIn)
		    ($--> "is" 'Is)
		    ($*--> "is" "not" 'IsNot)) `(ops ,$$)))

 (star_expr ($--> (seq "*" expr) `(Starred ,($ 2))))

 (expr (or ($--> (seq expr ($--> "|" 'BitOr) xor_expr) `(BinOp ,($ 1) ,($ 2) ,($ 3)))
                 xor_expr))

 (xor_expr (or ($--> (seq xor_expr ($--> "^" 'BitXor) and_expr) `(BinOp ,($ 1) ,($ 2) ,($ 3)))
                 and_expr))

 (and_expr (or ($--> (seq and_expr ($--> "&" 'BitAnd) shift_expr) `(BinOp ,($ 1) ,($ 2) ,($ 3)))
                 shift_expr))

 (shift_expr (or ($--> (seq shift_expr (or ($--> "<<" 'LShift)
					   ($--> ">>" 'RShift)) arith_expr) `(BinOp ,($ 1) ,($ 2) ,($ 3)))
                 arith_expr))

 (arith_expr (or ($--> (seq arith_expr (or ($--> "+" 'Add)
					   ($--> "-" 'Sub)) term) `(BinOp ,($ 1) ,($ 2) ,($ 3)))
             term))

 (term (or ($--> (seq term (or ($--> "*" 'Mult)
		          ($--> "/" 'Div)
		          ($--> "%" 'Mod)
		          ($--> "//" 'FloorDiv)) factor) `(BinOp ,($ 1) ,($ 2) ,($ 3)))
          factor))

 (factor (or ($--> (seq (or ($--> "+" 'UAdd)
                            ($--> "-" 'USub)
                            ($--> "~" 'Invert)) factor) `(UnaryOp ,($ 1) ,($ 2))) 
             power ))
 (power ($--> (seq atom (rep trailer) (opt ($--> (seq "**" factor) ($ 2))))
              (if ($ 3)
                  `(BinOp ,(process-trailers ($ 1) ($ 2)) Pow, ($ 3))
                  (process-trailers ($ 1) ($ 2)))))
 (atom
  (or ($*--> "(" (or yield_expr testlist_comp) ")" ($ 2))
      ($*--> "(" ")" '(Tuple))
      ($*--> "[" testlist_comp "]" `(Tuple ,($ 2)))
      ($*--> "[" "]" '(List))
      ($*--> "{" dictorsetmaker "}" ($ 2))
      ($*--> "{" "}" `(Dict (keys) (values)))
      ($--> (seq 'NAME) `(Name ,(string->symbol ($ 1))))
      ($--> 'NUMBER `(Num ,$$))
      ($--> (seq (rep+ 'STRING)) `(Str ,(apply string-append ($ 1))))
      ($--> "..." '(Ellipsis))
      ($--> "None" `(NameConstant ,(string->symbol $$)))
      ($--> "True" `(NameConstant ,(string->symbol $$)))
      ($--> "False" `(NameConstant ,(string->symbol $$)))))

 (testlist_comp
  (or ($*--> (or test star_expr) comp_for `(ListComp ,($ 1) ,($ 2)))
      ($*--> (or test star_expr) 
             (opt ",")
             (rep/sep "," (or test star_expr) #t) 
             (if ($ 3)
                 `(,($ 1) ,@($ 3))
                 `(,($ 1)))))) 
 (trailer
  (or ($*--> "(" arglist ")" ($ 2)) 
      ($*--> "(" ")" `((args ) (keywords ) (starargs #f) (kwargs #f)))
      ($*--> "[" subscriptlist "]" `(Index ,($ 2)))
      ($*--> "." 'NAME (string->symbol ($ 2)))))

 (subscriptlist (or ($*--> subscript ($ 1))
                    ($--> (rep+/sep "," subscript #t) `(Tuple ,@$$))))

 (subscript (or test
                ($*--> test ":" test (opt sliceop) (if ($ 4) `(Slice ,($ 1) ,($ 3) ,($ 4))  `(Slice ,($ 1) ,($ 3) #f)))
                ($*--> test ":" (opt sliceop)      (if ($ 3) `(Slice ,($ 1) #f ,($ 3))      `(Slice ,($ 1) #f #f)))
                ($*--> ":" test (opt sliceop)      (if ($ 3) `(Slice #f ,($ 2) ,($ 3))      `(Slice #f ,($ 2) #f )))
                ($*--> ":" (opt sliceop)           (if ($ 2) `(Slice #f #f ,($ 2))          `(Slice #f #f #f)))))
                        
 (sliceop ($*--> ":" 
                 (opt test)
                 (if ($ 2)
                  ($ 2)
                  #f )))

 (exprlist
  ($*--> (or expr star_expr) 
         ($--> (rep ($*--> "," (or expr star_expr) ($ 2))) $$)
         (opt ",")  
          (if (empty? ($ 2))
         `( ,($ 1) )
          `(,($ 1) ,($ 2)))))

 (testlist ($*--> test 
                  ($--> (rep ($*--> "," test ($ 2))) $$)
                  (opt ",")
		  (if (empty? ($ 2))
		   ($ 1)
		   `(Tuple ,($ 1) ,@($ 2)))))

 (dictorsetmaker
  (or ($*--> test
             ":"
             test
             comp_for
             `(DictComp ,($ 1) ,($ 3) ,($ 4)))
      ($--> ($*--> (rep+/sep "," ($*--> test ":" test `(,($ 1) ,($ 3))) #t) (recombine (car $$))) `(Dict (keys ,@(car $$)) (values ,(cadr $$))))
      ($*--> test comp_for `(SetComp ,($ 1) ,($ 2)))
      ($--> (rep+/sep "," test #t) `(Set ,@$$))))

 (classdef (seq "class" 'NAME (opt (seq "(" (opt arglist) ")")) ":" suite))

 (arglist
         ($--> ($*--> ($--> (rep ($*--> argument "," ($ 1))) $$) 
                      (or ($*--> argument (opt ",") `(() (,($ 1)) () ))
                          ($*--> "*" 
                                 test 
                                 ($--> (rep ($*--> "," argument ($ 2))) $$)
                                 (opt ($*--> "," "**" test ($ 3)))
                                 (if ($ 4)
                                  `(,($ 2) ,($ 3) ,($ 4))
                                  `(,($ 2) ,($ 3) ())))
                          ($*--> "**" test `(() () ,($ 2))))
                       (coalesce ($ 2) ($ 1)))

			   `(,`(args             ,@($ 0)) 
			     ,`(keywords         ,@($ 1)) 
			     ,`(starargs         ,@($ 2)) 
			     ,`(kwargs           ,@($ 3)))))

 (argument (or ($*--> test 
                      (opt comp_for)
                      (if ($ 2)
                       `(GeneratorExp ,($ 1) ,($ 2))
                       `( ,($ 1))))
               ($*--> test 
                      "=" 
                      test
                      `( ,(cadr ($ 1)) ,($ 3)))))

 (comp_iter (or comp_for comp_if))

 (comp_for ($*--> "for" exprlist "in" or_test (opt comp_iter)
					(if ($ 5)
					 `(for ,@($ 2) in ,($ 4) if ,@($ 5))
					 `(for ,@($ 2) in ,($ 4) if))))
 (comp_if ($*--> "if" test_nocond (opt comp_iter)
					(if ($ 3)
					 `(,($ 2) ,@($ 3))
					 `(,($ 2)))))
 (encoding_decl 'NAME)
 (yield_expr ($*--> "yield" 
                    (opt yield_arg) (if ($ 2)
                    ($ 2)
                    (`Yield))))
 (yield_arg (or ($*--> "from" test `(YieldFrom ,($ 2)))
                ($--> testlist `(Yield ,($ 1))))))
